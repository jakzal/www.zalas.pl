<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Jakub Zalas]]></title>
    <link href="http://www.zalas.pl/atom.xml" rel="self"/>
    <link href="http://www.zalas.pl/"/>
    <updated>2017-07-20T07:22:40+00:00</updated>
    <id>http://www.zalas.pl/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Encje Doctrine poza bundlami Symfony]]></title>
            <link href="http://www.zalas.pl/encje-doctrine-poza-bundlami-symfony/"/>
            <updated>2013-01-26T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/encje-doctrine-poza-bundlami-symfony/</id>
            <content type="html"><![CDATA[<p><a href="https://github.com/doctrine/DoctrineBundle">DoctrineBundle</a> i <a href="https://github.com/symfony/symfony/tree/master/src/Symfony/Bridge/Doctrine">bridge</a> odpowiadają za integracje Doctrine ORM z frameworkiem Symfony. Jedną z funkcjonalności jaką oferuje <em>DoctrineBundle</em> jest automatyczna rejestracja mapowań w bundlach. Dopóki stosujemy się do konwencji, tzn umieszczamy encje w katalogu <em>Entity</em>, czy też mapowania w <em>Resources/config/doctrine</em>, doctrine zauważy naszą konfigurację i ją automatycznie zarejestruje. Wszystko dzięki domyślnie włączonej (w standardowej dystrybucji Symfony) opcji <a href="http://symfony.com/doc/current/reference/configuration/doctrine.html#configuration-overview">auto mapping</a>. Jest to bardzo wygodne, bo nie musimy dużo robić, aby zacząć pracę z ORMem.</p>

<p>Z drugiej strony czasem lepiej jest, gdy nasze encje nie są częścią bundla, ale leżą gdzieś w ogólnej przestrzeni nazw. Jest to często lepsze podejście, jeśli nasze encje używane są w wielu bundlach lub nawet projektach. Największą zaletą tej metody jest odseparowanie warstwy ORMa od Symfony. Wydzielając ją do katalogu poza bundlem tworzymy bibliotekę, która jest niezależna od Symfony i może być potencjalnie użyta w dowolnym projekcie PHP.</p>

<div class="text-center">
    <a href="/uploads/wp/2013/01/entities.png"><img src="/uploads/wp/2013/01/entities.png" title="Encje" alt="Encje" class="img-responsive" /></a>
</div>

<p>Najlepszym miejscem by <a href="http://symfony.com/doc/current/reference/configuration/doctrine.html#mapping-configuration">skonfigurować mapowanie</a> jest plik <em>app/config/config.yml</em>:</p>

<pre><code>doctrine:
    orm:
        # ...
        mappings:
            Acme:
                type: annotation
                is_bundle: false
                dir: %kernel.root_dir%/../src/Acme/Entity
                prefix: Acme\Entity
                alias: Acme
</code></pre>

<p>W powyższym przykładzie użyliśmy adnotacji, stąd opcja <em>dir</em> jest ścieżką do katalogu z encjami. W przypadku mapowania <em>xml</em> czy <em>yml</em> byłaby to ścieżka do katalogu z plikami <em>xml/yml</em>. <em>Prefix</em> jest fragmentem przestrzeni nazw naszych encji i powinien być unikalny. Dzięki <em>aliasowi</em> będziemy mogli odnosić się do encji przy pomocy krótszej notacji. Przykładowo zamiast:</p>

<pre><code>$entityManager-&gt;getRepository('Acme\Entity\Invoice');
</code></pre>

<p>użylibyśmy:</p>

<pre><code>$entityManager-&gt;getRepository('Acme:Invoice');
</code></pre>

<p>Oczywiście możemy zdefiniować tyle mapowań ile tylko potrzebujemy, co pozwala nam grupować encje w niezależne przestrzenie nazw oraz używać odmiennych metod mapowania:</p>

<pre><code>doctrine:
    orm:
        # ...
        mappings:
            AcmeCustomer:
                type: annotation
                is_bundle: false
                dir: %kernel.root_dir%/../src/Acme/Customer/Entity
                prefix: Acme\Customer\Entity
                alias: Customer
            AcmeCms:
                type: yml
                is_bundle: false
                dir: %kernel.root_dir%/../src/Acme/Cms/Entity/config
                prefix: Acme\Cms\Entity
                alias: CMS
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Live Londyn 2012]]></title>
            <link href="http://www.zalas.pl/symfony-live-londyn-2012/"/>
            <updated>2012-09-19T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/symfony-live-londyn-2012/</id>
            <content type="html"><![CDATA[<div class="pull-left">
    <img src="/uploads/wp/2012/09/sflive-london-2012.png" title="Symfony Live London 2012" alt="Symfony Live London 2012" class="img-responsive" />
</div>

<p>Świetne prezentacje, przyjaźni prelegenci i wspaniała społeczność. Pierwsza konferencja **<a href="http://london2012.live.symfony.com/">Symfony Live** w <strong>Londynie</strong></a> okazała się dużym sukcesem. Cieszę się z tego podwójnie, jako że niedawno dołączyłem do ekipy **<a href="http://www.sensiolabs.co.uk/">Sensio Labs UK**</a>, organizatora konferencji ;) Wysłuchaliśmy wielu ekscytujących prezentacji, wygłoszonych przez jednych z najlepszych prelegentów ze społeczności Symfony. Widać było, że coraz lepiej integrujemy się z programistami Drupala. Lider tego projektu podzielił się kilkoma sekretami na zbudowanie silnej społeczności. Muszę przyznać, że nieco nam jeszcze brakuje do Drupalowej paczki. Dla mnie jednak najważniejszym wydarzeniem była prezentacja <a href="https://twitter.com/_md">Marcello</a> i <a href="https://twitter.com/everzet">Konstantin</a>a na tamat "<em>Pełnego BDD w Symfony2</em>" (ang. "<em>Full Stack BDD in Symfony2</em>") i na tym skupię swoją relację. Jeśli nie jesteście zainteresowani BDD, pora przestać czytać... ...a może właśnie najwyższa pora zacząć interesować się tą metodyką!</p>

<div class="pull-right">
    <a href="http://instagram.com/p/Pj6SettmxK/"><img src="/uploads/wp/2012/09/konstantin-and-marcello-400x400.jpg" title="Konstantin i Marcello" alt="Konstantin i Marcello" class="img-responsive" /></a>
</div>

<p>Chłopaki wystartowali z energetycznym wprowadzeniem do Behavior Driven Development (BDD), tłumacząć <strong>dlaczego</strong> warto stosować tą metodykę, omawiając zalety podejścia "<strong>outside-in</strong>" i udowadniając, że najlepszym sposobem na zapewnienie wysokiej <strong>jakości</strong> produktu jest podejście test-first (pisanie testów przed kodem produkcyjnym). Przypomnieli nam też jak ważne jest <strong>nazewnictwo</strong>. Terminologia jest główną przyczyną problemów i nieporozumień związanych z narzędziamy typu xUnit. Dlatego dobór słów i sposób w jaki komunikujemy się poprzez testy jest bardzo ważny. Tak, <strong>komunikujemy!</strong> Testy stanowią (zawsze aktualną) dokumentację naszego kodu i stąd powinny być czytelne. Czy uważacie testy napisane w PHPUnit za czytelne? Może, gdy już przebrniemy przez niekończące się ekrany wywołań definiujących moki... Czy potraficie bez problemu zrozumieć swój test napisany choćby tydzień temu? Niestety PHPUnit nie został zaprojektowany z myślą o pisaniu testów przed kodem. <strong>Behat</strong> doskonale sprawdza się w tzw <strong>StoryBDD</strong>. Niestety jak dotąd nie mieliśmy porządnego narzędzia działającego na poziomie <strong>SpecBDD</strong>. Pracując z Behatem i PHPUnit często jestem wybijany z rytmu, będąc zmuszany do zmiany kontekstu między tymi narzędziami.  Do niedawna nie rozumiałem dlaczego tak się dzieje. Dopóki nie uświadomiłem sobie, że PHPUnit jest niewłaściwym narzędziem do tego typu pracy (pomogła mi w tym lektura <a href="http://pragprog.com/book/achbd/the-rspec-book">RSpec book</a>). Marcello i Konstantin doświadczyli tych samych problemów i postanowili im zaradzić. Stworzyli nową wersję PHPSpec (PHPSpec2), ktorą po raz pierwszy zaprezentowali światu na swojej prezentacji w Londynie. PHPSpec2 jest to alternatywą dla PHPUnit, lepiej dostosowaną do podejścia BDD, używającą lepszej terminologii. Zmiana kontekstu między Behatem a PHPSpec nie wybija z rytmu. PHPSpec idealnie uzupełnia Behata, pozwalając na sprawne pisanie czytelnych testów. Wracając do prezentacji... jej druga część skupiła się na tym jak zastosować teorię w praktyce. Chłopaki po raz pierwszy zaprezentowali <strong>jak</strong> powinien wyglądać pełny cykl <strong>BDD</strong> w <strong>Symfony2</strong> z punktu widzenia programisty. To było niesamowite 20 minut pokazujące jak można testami napędzać implementację nowej funkcjonalności, sprawnie przechodząc między Behatem (scenariuszami) i PHPSpec2 (specyfikacjami), płynnie powtarzając cykl dopóki funkcjonalność nie zostanie ukończona. Oba narzędzia praktycznie sugerowały kolejne kroki implementacji. Jestem pewien, że pokazując to na żywo, chłopaki przekonali nie jednego sceptyka. Udowodnili nie tylko, że podejście test-first wcale nie zajmuje więcej czasu, ale de-facto jest możliwe działać sprawniej niż "tradycyjnie" testując swój kod w przeglądarce. Mam nadzieję, że moja krótka relacja pogłębiła Wasze zainteresowanie BDD. Proponuję kontynuować czytając <a href="http://everzet.com/post/31581124270/fullstack-bdd-2012-wrapup">wpis Konstantina, w którym podsumowuje swoją prezentację</a>. Następnie warto prześledzić pełen cykl w <a href="https://github.com/everzet/fullstack-bdd-sflive2012">specjalnie do tego celu przygotowanym repozytorium</a>. Wytrwali mogą zajrzeć w kod <a href="https://github.com/phpspec/phpspec2">PHPSpec2</a> (nad którym prace ciągle trwają).</p>

<p><strong>Uwaga</strong>: Ponieważ terminologia jest ważna, powinniśmy unikać słowa "test". Rozmawiając o "testach" dajemy do zrozumienia, że chcemy coś testować lub sprawdzać, podczas gdy w metodykach TDD/BDD nie o to chodzi. TDD jest czynnością bliższą projektowaniu niż testowaniu. Głównym zadaniem podczas rozwijania kodu z podejściem TDD jest projektowanie naszego kodu przy pomocy testów. Z powodu tych nieporozumień BDD redefiniuje "testy" jako "specyifkacje".</p>

<h2 id="wi%C4%99cej-o-konferencji">Więcej o konferencji</h2>

<p>Jak zwykle, feedback uczestników znajdziecie na <a href="https://joind.in/event/view/1000">joind.in</a>. Warto też przeczytać relacje innych:</p>

<ul>
<li><a href="http://criticallog.thornet.net/2012/09/14/symfony2-live-london-aftermatch/">Symfony2 Live! London – aftermatch</a></li>
<li><a href="http://xlab.pl/symfony-live-london-2012-recap/">Symfony Live London 2012 recap</a></li>
<li><a href="http://www.sensiolabs.co.uk/blog/symfony-live-london-a-huge-success/">Symfony Live London – A Huge Success</a></li>
<li><a href="http://everzet.com/post/31581124270/fullstack-bdd-2012-wrapup">Fullstack BDD wrap up</a></li>
</ul>

<p>Na koniec, trochę zdjęć na <a href="http://www.flickr.com/photos/sensiolabsuk/sets/72157631558775580/">flickr</a>.</p>

<p>Do zobaczenia w <a href="http://berlin2012.live.symfony.com/en/index.html">Berlinie na kolejnej Symfony Live</a>!</p>

<div class="text-center">
    <a href="/uploads/wp/2012/09/polish-symfony-community-london-2012.jpg"><img src="/uploads/wp/2012/09/polish-symfony-community-london-2012-400x300.jpg" title="Polska reprezentacja Symfony" alt="Polska reprezentacja Symfony" class="img-responsive" /></a>
</div>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Zarządzanie konstrukcją obiektów w PHP z komponentem DependencyInjection Symfony2]]></title>
            <link href="http://www.zalas.pl/zarzadzanie-konstrukcja-obiektow-w-php-z-komponentem-dependencyinjection-symfony2/"/>
            <updated>2011-09-07T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/zarzadzanie-konstrukcja-obiektow-w-php-z-komponentem-dependencyinjection-symfony2/</id>
            <content type="html"><![CDATA[<p>Komponent <a href="https://github.com/symfony/DependencyInjection">DependencyInjection</a> Symfony2 to PHPowa implementacja <strong>kontenera usług</strong> (z ang. <strong>Dependency Injection Container</strong>). Dodatkowo, komponent zawiera kilka przydatnych narzędzi, pozwalających na import i eksport definicji w różnych formatach (np <em>XML</em>).</p>

<div class="text-center">
    <img src="/uploads/wp/2011/08/injection.png" title="Injection - oryginał zdjęcia: http://www.flickr.com/photos/alexnormand/3132689510/" alt="Injection - oryginał zdjęcia: http://www.flickr.com/photos/alexnormand/3132689510/" class="img-responsive" />
</div>

<p>Jeśli chcecie dowiedzieć się więcej o kontenerze usług lub wstrzykiwaniu zależności, polecam świetną serię artykułów autorstwa Fabiena Potencier: <a href="http://fabien.potencier.org/article/11/what-is-dependency-injection">What is Dependency Injection?</a> <strong>Uwaga</strong>: Kod z tego artykułu dostępny jest na githubie: <a href="https://github.com/jakzal/SymfonyComponentsExamples">https://github.com/jakzal/SymfonyComponentsExamples</a></p>

<h2 id="instalacja">Instalacja</h2>

<p>Komponent możemy zainstalować za pomocą <a href="http://pear.symfony.com/">kanału PEAR Symfony2</a> lub go po prostu pobrać z <a href="https://github.com/symfony/Finder">github</a>a. Na potrzeby tego wpisu sklonujemy źródła do katalogu <em>vendor/</em> naszego projektu. Będziemy też potrzebować Buzz, lekkiego klienta HTTP, który posłuży nam za przykład usługi. W jednym z fragmentów kodu pojawi się komponent <a href="https://github.com/symfony/Config/">Config</a>.</p>

<pre><code>git clone https://github.com/symfony/DependencyInjection.git vendor/Symfony/Component/DependencyInjection
git clone https://github.com/symfony/Config.git vendor/Symfony/Component/Config
git clone https://github.com/symfony/ClassLoader.git vendor/Symfony/Component/ClassLoader
git clone https://github.com/kriswallsmith/Buzz.git vendor/Buzz
</code></pre>

<p>Użyjemy komponentu ClassLoader do automatycznego ładowania klas. Więcej o nim przeczytacie we wpisie  "<a href="/automatyczne-ladowanie-klas-w-dowolnym-projekcie-php-z-komponentem-classloader-symfony2">Automatyczne ładowanie klas w dowolnym projekcie PHP z komponentem ClassLoader Symfony2</a>". Poniższy kod wystarczy, aby wszystkie klasy z dowolnego komponentu Symfony2 były automatycznie ładowane (zakładając, że komponenty są umieszczane w katalogu <em>vendor/Symfony/Component</em>):</p>

<pre><code>&lt;?php
// src/autoload.php
require_once __DIR__.'/../vendor/Symfony/Component/ClassLoader/UniversalClassLoader.php';

$loader = new Symfony\Component\ClassLoader\UniversalClassLoader();
$loader-&gt;registerNamespaces(array(
    'Symfony' =&gt; __DIR__.'/../vendor',
    'Buzz'    =&gt; __DIR__.'/../vendor/Buzz/lib',
    'PSS'     =&gt; __DIR__
));
$loader-&gt;register();
</code></pre>

<h2 id="tworzenie-obiekt%C3%B3w-metoda-klasyczna">Tworzenie obiektów (metoda klasyczna)</h2>

<p>Buzz jest klientem HTTP. Z jego pomocą możemy wysyłać żądanie do strony www i odebrać odpowiedź:</p>

<pre><code>$browser = new \Buzz\Browser();
$response = $browser-&gt;get('http://www.google.com');
</code></pre>

<p>Domyślnie Buzz używa do połączeń strategii <em>FileGetContents</em>, która opakowuje funkcję <em>file_get_contents()</em>. Wyobraźmy sobie, że nowe wymagania wymusiły na nas użycie curla. Nic prostszego. Wystarczy, że przekażemy odpowiedniego klienta do obiektu <em>Browser</em>:</p>

<pre><code>$client = new \Buzz\Client\Curl();
$browser = new \Buzz\Browser($client);
$response = $browser-&gt;get('http://www.google.com');
</code></pre>

<p>Po jakimś czasie zaobserwowaliśmy, że czas żądania często przekracza domyślny limit pięciu sekund. Zwiększamy go do piętnastu:</p>

<pre><code>$client = new \Buzz\Client\Curl();
$client-&gt;setTimeout(15);

$browser = new \Buzz\Browser($client);
$response = $browser-&gt;get('http://www.google.com');
</code></pre>

<p>Zauważmy, że modyfikacji musimy wprowadzić wszędzie, gdzie używany jest Buzz. Taki kod szybko staje się zagmatwany i trudny w utrzymaniu. Wprawdzie do konstrukcji obiektu <em>Browser</em> moglibyśmy użyć fabryki, jednak pisanie takiej klasy dla każdej z naszych usług jest powtarzalną czynnością. Nie bylibyśmy <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> przez tworzenie wielu klas o podobnym przeznaczeniu. Innym rozwiązaniem jest <strong>centralizacja tworzenia obiektów</strong>. Właśnie za to odpowiedzialny jest kontener usług (DIC).</p>

<h2 id="tworzenie-obiekt%C3%B3w-z-dic">Tworzenie obiektów z DIC</h2>

<p>Zamiast jawnie utworzyć obiekt klasy Browser, <strong>powiemy kontenerowi usług jak to zrobić</strong>:</p>

<pre><code>&lt;?php
// dependencyinjection.php

require_once __DIR__.'/src/autoload.php';

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;

$serviceContainer = new ContainerBuilder();

$browserDefinition = new Definition('Buzz\Browser');
$serviceContainer-&gt;setDefinition('browser', $browserDefinition);
</code></pre>

<p>Następnie <strong>zarządamy dostępu do usługi</strong>:</p>

<pre><code>$browser = $serviceContainer-&gt;get('browser');
$response = $browser-&gt;get('http://www.google.com/');
</code></pre>

<p>Aby zastąpić domyślnego klienta HTTP, utworzymy definicję kolejnej usługi i przekażemy ją do poprzedniej jako referencję:</p>

<pre><code>&lt;?php
// dependencyinjection.php

// ...

$serviceContainer = new ContainerBuilder();

$clientDefinition = new Definition('Buzz\Client\Curl');
$clientDefinition-&gt;addMethodCall('setTimeout', array(15));
$serviceContainer-&gt;setDefinition('browser.client', $clientDefinition);

$browserDefinition = new Definition('Buzz\Browser', array(new Reference('browser.client')));
$serviceContainer-&gt;setDefinition('browser', $browserDefinition);
</code></pre>

<p>Zauważmy, że chociaż tworzenie obiektu się komplikuje, zarządzamy nim w jednym miejscu. Kod, który go używa pozostaje prosty:</p>

<pre><code>$browser = $serviceContainer-&gt;get('browser');
</code></pre>

<p>Podczas, gdy definicja usługi się zmienia, kod, który ją konsumuje pozostaje nienaruszony. <strong>Uwaga</strong>: Oczywiście, obiekt nie zostanie utworzony, jeśli go nigdy nie pobierzemy z kontenera.</p>

<h2 id="opisywanie-us%C5%82ug-w-xml">Opisywanie usług w XML</h2>

<p>Usługi możemy opisywać w różnych formatach, nie tylko PHP. Komponent <em>DependencyInjection</em> dostarcza nam narzędzia do zapisywania i ładowania definicji usług. Szczególnie kusząca jest perspektywa konfiguracji usług w formatach <strong>Yaml</strong> lub <strong>XML</strong>. W ten sposób <strong>separacja</strong> między konstrukcją obiektu, a jego konsumentem będzie bardziej widoczna. Poza tym definicje usług staną się <strong>czytelniejsze</strong>. Poniższy fragment kodu <em>XML</em> opisuje te same usługi, które wcześniej zdefiniowaliśmy w PHP:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;-- config/buzz.xml --&gt;
&lt;container xmlns="http://symfony.com/schema/dic/services"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
  &lt;services&gt;
    &lt;service id="browser.client" class="Buzz\Client\Curl"&gt;
      &lt;call method="setTimeout"&gt;
        &lt;argument&gt;15&lt;/argument&gt;
      &lt;/call&gt;
    &lt;/service&gt;
    &lt;service id="browser" class="Buzz\Browser"&gt;
      &lt;argument type="service" id="browser.client"/&gt;
    &lt;/service&gt;
  &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>Załadowanie usług do kontenera jest trywialne. Tworzymy <em>CotnainerBuilder</em> i przekazujemy go do <em>XmlFileLoader</em>, który zajmie się  resztą:</p>

<pre><code>&lt;?php
// dependencyinjectionloader.php

require_once __DIR__.'/src/autoload.php';

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
</code></pre>

<p>Proces odwrotny jest równie prosty. Usługi zapiszemy do XMLa przekazując ContainerBuilder do XmlDumper:</p>

<pre><code>&lt;?php
// dependencyinjection.php

// ...

use Symfony\Component\DependencyInjection\Dumper\XmlDumper;

$dumper = new XmlDumper($serviceContainer);
echo $dumper-&gt;dump();
</code></pre>

<p><strong>Uwaga</strong>: W prawdziwym projekcie prawdopodobnie utrzymywalibyśmy usługi w XMLu lub YMLu, ale używali ich po uprzedniej konwersji do PHP (przy pomocy PhpDumper). W ten sposób moglibyśmy czerpać korzyści zarówno z maksymalnej <strong>wydajności</strong> jak i <strong>czytelnej</strong> konfiguracji.</p>

<h2 id="wizualizacja-us%C5%82ug">Wizualizacja usług</h2>

<p>W rozbudowanych aplikacjach ilość usług i powiązań między nimi może być spora i skomplikowana. GraphvizDumper pomoże nam wygenerować wykres usług, dzięki któremu łatwiej rozeznamy się w sytuacji.</p>

<pre><code>&lt;?php
// dependencyinjectiongraphviz.php

require_once __DIR__.'/src/autoload.php';

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Dumper\GraphvizDumper;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
use Symfony\Component\Config\FileLocator;

$serviceContainer = new ContainerBuilder();
$loader = new XmlFileLoader($serviceContainer, new FileLocator(__DIR__.'/config'));
$loader-&gt;load('buzz.xml');

$dumper = new GraphvizDumper($serviceContainer);
echo $dumper-&gt;dump();
</code></pre>

<p>Wynik musimy zapisać do pliku (np services.dot). Do wygenerowania wykresu potrzebujemy programu dot (z pakietu graphviz):</p>

<pre><code>dot -Tpng -o services.png services.dot
</code></pre>

<p>Wynik powinien być zbliżony do poniższego obrazka.</p>

<div class="text-center">
    <a href="/uploads/wp/2011/08/services.png"><img src="/uploads/wp/2011/08/services-400x112.png" alt="Services" /></a>
</div>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony 2.0 wydane!]]></title>
            <link href="http://www.zalas.pl/symfony-2-0-wydane/"/>
            <updated>2011-07-28T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/symfony-2-0-wydane/</id>
            <content type="html"><![CDATA[<p>Dziś, 28go lipca 2011 roku, <a href="http://symfony.com/blog/symfony-2-0">wydano stabilną wersję Symfony 2</a>. Czekaliśmy nieco dłużej niż planowano, ale było warto!</p>

<div class="text-center">
    <img src="/uploads/wp/2011/07/symfonylab-header.png" title="ElePHPant w Paryżu" alt="ElePHPant w Paryżu" class="img-responsive" />
</div>

<p><a href="http://pooteeweet.org/blog/0/1915">Społeczność Symfony pcha ekosystem PHP do przodu</a> już od jakiegoś czasu. Wyznacza trendy i standardy nie tylko rozwijając framework, ale także pracując nad wieloma <strong>wysokiej jakości</strong> narzędziami i bibliotekami (takimi jak Behat, Assetic, czy Twig). Cała idea niezależnych komponentów wprowadza <strong>nową jakość</strong> do świata <strong>PHP</strong>.</p>

<p>Stabilne wydanie Symfony2 rozpoczyna <a href="http://blog.webspecies.co.uk/2011-05-23/the-new-era-of-php-frameworks.html">nową erę fremeworków PHP</a>.</p>

<p>Osobiście, na początku 2007 roku, miałem zamiar porzucić PHP i zająć się inną technologią. Wydanie symfony 1.0 sprawiło, że zostałem jeszcze na długo.</p>

<p>Dzisiaj Symfony2 ponownie <strong>przywraca mi wiarę w PHP</strong>. Wielkie podziękowania dla wszystkich, którzy <a href="http://symfony.com/contributors">się do tego przyczynili</a>!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Wyszukiwanie plików i katalogów w PHP z komponentem Finder Symfony2]]></title>
            <link href="http://www.zalas.pl/wyszukiwanie-plikow-i-katalogow-w-php-z-komponentem-finder-symfony2/"/>
            <updated>2011-07-07T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/wyszukiwanie-plikow-i-katalogow-w-php-z-komponentem-finder-symfony2/</id>
            <content type="html"><![CDATA[<p><a href="https://github.com/symfony/Finder">Komponent Finder</a> sprawia, że wyszukiwanie plików i katalogów w PHP przestaje być męczące. Pozwala na filtrowanie po nazwie, wzorcu, rozmiarze, dacie modyfikacji i kilku innych kryteriach. W wyniku dostaniemy listę obiektów klasy <a href="http://php.net/splfileinfo">SplFileInfo</a>, która oferuje wygodny interfejs do pozyskiwania szczegółów na temat plików i katalogów. <strong>Uwaga</strong>: Kod tworzony w tym wpisie jest dostępny na githubie: <a href="https://github.com/jakzal/SymfonyComponentsExamples">https://github.com/jakzal/SymfonyComponentsExamples</a></p>

<h2 id="instalacja">Instalacja</h2>

<p>Komponent możemy zainstalować za pomocą <a href="http://pear.symfony.com/">kanału PEAR Symfony2</a> lub go po prostu pobrać z <a href="https://github.com/symfony/Finder">github</a>a. Na potrzeby tego wpisu sklonujemy źródła do katalogu <em>vendor/</em> naszego projektu.</p>

<pre><code>git clone https://github.com/symfony/Finder.git vendor/Symfony/Component/Finder
</code></pre>

<p>Użyjemy ClassLoader, innego komponentu Symfony2, do automatycznego ładowania klas. Więcej o tym komponencie we wpisie  "<a href="/automatyczne-ladowanie-klas-w-dowolnym-projekcie-php-z-komponentem-classloader-symfony2">Automatyczne ładowanie klas w dowolnym projekcie PHP z komponentem ClassLoader Symfony2</a>". Poniższy kod wystarczy, aby wszystkie klasy z dowolnego komponentu Symfony2 były automatycznie ładowane (zakładając, że komponenty są umieszczane w katalogu <em>vendor/Symfony/Component</em>):</p>

<pre><code>&lt;?php
// src/autoload.php
require_once __DIR__.'/../vendor/Symfony/Component/ClassLoader/UniversalClassLoader.php';

$loader = new Symfony\Component\ClassLoader\UniversalClassLoader();
$loader-&gt;registerNamespaces(array(
    'Symfony' =&gt; __DIR__.'/../vendor',
    'PSS'     =&gt; __DIR__
));
$loader-&gt;register();
</code></pre>

<h2 id="przyk%C5%82ady">Przykłady</h2>

<p>Główną klasą komponentu, z którą będziemy pracować, to <em>Finder.</em> Po utworzeniu obiektu metodą <em>create()</em> użyjemy płynnego interfejsu (ang. <a href="http://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a>), aby zdefiniować kryteria. Metod filtrujących i sortujących najlepiej nauczymy się ze źródeł klasy <a href="https://github.com/symfony/Finder/blob/master/Finder.php">Finder</a>. <strong>Przykład 1</strong>: Poniższy skrypt wypisze komponenty Symfony zainstalowane w katalogu <em>vendor/Symfony/Component</em>:</p>

<pre><code>&lt;?php
// finderdir.php
require_once __DIR__.'/src/autoload.php';

use Symfony\Component\Finder as Finder;

$components = Finder\Finder::create()
    -&gt;directories()
    -&gt;depth(0)
    -&gt;in('vendor/Symfony/Component');

echo "Installed Symfony components:\n";
foreach ($components as $dir) {
    printf("* %s \n", $dir-&gt;getFilename());
}
</code></pre>

<p><strong>Przykład 2, bardziej wyrafinowany</strong>: Poniższy skrypt wypisze pliki pasujące do wzorca <em>/^He.+Command.php$/</em>, mniejsze niż <em>4kb</em> i zmodyfikowane <em>do wczoraj</em>. Wynik zostanie posortowany po <em>nazwie pliku</em>, a szukać będziemy w <em>aktualnym katalogu</em>:</p>

<pre><code>&lt;?php
// finder.php
require_once __DIR__.'/src/autoload.php';

use Symfony\Component\Finder as Finder;

$files = Finder\Finder::create()
    -&gt;files()
    -&gt;name('/^He.+Command.php$/')
    -&gt;size('&lt;4k')
    -&gt;date('until yesterday')
    -&gt;sortByName()
    -&gt;in('.');

echo "Command files starting with 'He' below 4k modified until yesterday:\n";
foreach ($files as $file) {
    printf("* %s %s\n", $file-&gt;getFilename(), date('Y-m-d H:i', $file-&gt;getMTime()));
}
</code></pre>

<p>Proste, nieprawdaż?</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Tworzenie sparametryzowanych komend w PHP z komponentem Console Symfony2]]></title>
            <link href="http://www.zalas.pl/tworzenie-sparametryzowanych-komend-w-php-z-komponentem-console-symfony2/"/>
            <updated>2011-07-04T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/tworzenie-sparametryzowanych-komend-w-php-z-komponentem-console-symfony2/</id>
            <content type="html"><![CDATA[<p><img src="/uploads/wp/2011/07/console-150x150.png" alt="" /><a href="https://github.com/symfony/Console">Komponent Console</a> Symfony2 ułatwia tworzenie sparametryzowanych komend w PHP. Odpowiada za niewdzięczną pracę parsowania wejścia i pisania na wyjście. <strong>Uwaga</strong>: Kod tworzony w tym wpisie jest dostępny na githubie: <a href="https://github.com/jakzal/SymfonyComponentsExamples">https://github.com/jakzal/SymfonyComponentsExamples</a></p>

<h2 id="instalacja">Instalacja</h2>

<p>Komponent możemy zainstalować za pomocą <a href="http://pear.symfony.com/">kanału PEAR Symfony2</a> lub go po prostu pobrać z <a href="https://github.com/symfony/Console">github</a>a. Na potrzeby tego wpisu sklonujemy źródła do katalogu <em>vendor/</em> naszego projektu.</p>

<pre><code>git clone https://github.com/symfony/Console.git vendor/Symfony/Component/Console
</code></pre>

<p>Użyjemy ClassLoader, innego komponentu Symfony2, do automatycznego ładowania klas. Więcej o tym komponencie we wpisie  "<a href="/automatyczne-ladowanie-klas-w-dowolnym-projekcie-php-z-komponentem-classloader-symfony2">Automatyczne ładowanie klas w dowolnym projekcie PHP z komponentem ClassLoader Symfony2</a>". Poniższy kod wystarczy, aby wszystkie klasy z dowolnego komponentu Symfony2 były automatycznie ładowane (zakładając, że komponenty są umieszczane w katalogu <em>vendor/Symfony/Component</em>):</p>

<pre><code>&lt;?php
// src/autoload.php
require_once __DIR__.'/../vendor/Symfony/Component/ClassLoader/UniversalClassLoader.php';

$loader = new Symfony\Component\ClassLoader\UniversalClassLoader();
$loader-&gt;registerNamespaces(array(
    'Symfony' =&gt; __DIR__.'/../vendor',
    'PSS'     =&gt; __DIR__
));
$loader-&gt;register();
</code></pre>

<p>Przestrzeń nazw PSS posłuży naszym klasom.</p>

<h2 id="tworzenie-aplikacji-konsolowej">Tworzenie aplikacji konsolowej</h2>

<p>Aplikacja konsolowa pomoże nam zarządzać komendami:</p>

<pre><code>&lt;?php
// console.php
require_once __DIR__.'/src/autoload.php';

use Symfony\Component\Console as Console;

$application = new Console\Application('Demo', '1.0.0');
$application-&gt;run();
</code></pre>

<p>Jeśli uruchomimy skrypt bez argumentów, zobaczymy przegląd domyślnych opcji i komend.</p>

<p><img src="/uploads/wp/2011/06/console-options-400x241.png" alt="" /></p>

<p>Istnieją dwie wbudowane komendy: help i list.</p>

<h2 id="tworzenie-komendy">Tworzenie komendy</h2>

<p>Komendę tworzymy rozszerzając klasę Command i implementując w niej metodę <em>execute()</em>.</p>

<pre><code>&lt;?php
// src/PSS/Command/HelloWorldCommand.php
namespace PSS\Command;

use Symfony\Component\Console as Console;

class HelloWorldCommand extends Console\Command\Command
{
    protected function execute(Console\Input\InputInterface $input, Console\Output\OutputInterface $output)
    {
        $output-&gt;writeln('Hello World!');
    }
}
</code></pre>

<p>Metoda przyjmuje obiekty wejścia i wyjścia jako parametry (<em>$input</em> i <em>$output</em>). Obiektu wejścia będziemy używać, aby dostać się do argumentów i opcji przekazanych do skryptu. Obiekt wyjścia jest pomocy przy drukowaniu komunikatów (np na ekran). Każda komenda musi być zarejestrowana w aplikacji:</p>

<pre><code>&lt;?php
// console.php
require_once __DIR__.'/src/autoload.php';

use Symfony\Component\Console as Console;

$application = new Console\Application('Demo', '1.0.0');
**$application-&gt;add(new PSS\Command\HelloWorldCommand('hello-world'));**
$application-&gt;run();
</code></pre>

<p>Skrypt przyjmuje nazwę komendy jako pierwszy argument . Naszą komendę wywołamy przez:</p>

<pre><code>php console.php hello-world
</code></pre>

<p>W wyniku powinniśmy zobaczyć "Hello World!" wypisane na ekran.</p>

<h2 id="dodajemy-argumenty-i-opcje">Dodajemy argumenty i opcje</h2>

<p>Argumentów i opcji możemy użyć, aby sparametryzować i zmienić zachowanie naszej komendy. Zmodyfikujemy komendę HelloWorld, aby przyjmowała imię jako parametr. Wydrukujemy je później na ekran. Dodamy też opcję "-<em>-more</em>", która sprawi, że komenda wypisze dodatkowy komunikat. Argumenty i opcje, które chcemy móc przekazywać do komendy, deklarujemy odpowiednio metodami <em>addArgument()</em> i <em>addOption()</em>. Możemy uczynić je opcjonalnymi lub wymaganymi, dodać opis i wartości domyślne. Podane w linii poleceń parametry pobieramy po prostu z obiektu wejścia (<em>$input)</em> przekazanego do metody <em>execute()</em> (Aplikacja konsolowa zajmie się szczegółami).</p>

<pre><code>&lt;?php
// src/PSS/Command/HelloWorldCommand.php
namespace PSS\Command;

use Symfony\Component\Console as Console;

class HelloWorldCommand extends Console\Command\Command
{
    public function __construct($name = null)
    {
        parent::__construct($name);

        $this-&gt;setDescription('Outputs welcome message');
        $this-&gt;setHelp('Outputs welcome message.');
        $this-&gt;addArgument('name', Console\Input\InputArgument::OPTIONAL, 'The name to output to the screen', 'World');
        $this-&gt;addOption('more', 'm', Console\Input\InputOption::VALUE_NONE, 'Tell me more');
    }

    protected function execute(Console\Input\InputInterface $input, Console\Output\OutputInterface $output)
    {
        $name = $input-&gt;getArgument('name');

        $output-&gt;writeln(sprintf('Hello %s!', $name));

        if ($input-&gt;getOption('more')) {
            $output-&gt;writeln('It is really nice to meet you!');
        }
    }
}
</code></pre>

<p>Teraz możemy użyć nowo dodanego argumentu i opcji:</p>

<pre><code>php console.php hello-world -m Kuba
</code></pre>

<p>Dodatkowe wywołania <em>setDescription()</em> i <em>setHelp()</em> w konstruktorze ustawiają opis komendy i komunikat pomocy. Są bardzo przydatne, gdy nasz skrypt ma być używany przez innych. Pomoc uzyskamy wywołując komendę <em>help</em> z nazwą naszej komendy przekazaną jako argument:</p>

<pre><code>php console.php help hello-world
</code></pre>

<p><img src="/uploads/wp/2011/06/console-help-400x158.png" alt="" /></p>

<h2 id="interaktywna-pow%C5%82oka">Interaktywna powłoka</h2>

<p>Poprzez opakowanie aplikacji konsolowej obiektem klasy Shell, łatwo zyskamy funkcjonalność interaktywnej powłoki:</p>

<pre><code>&lt;?php
// consoleshell.php
require_once __DIR__.'/src/autoload.php';

use Symfony\Component\Console as Console;

$application = new Console\Application('Demo', '1.0.0');
$application-&gt;add(new PSS\Command\HelloWorldCommand('hello-world'));

$shell = new Console\Shell($application);
$shell-&gt;run();
</code></pre>

<p>W ten sposób skrypt nie zakończy działania zaraz po uruchomieniu, ale będzie czekał na nasze komendy:</p>

<pre><code>php consoleshell.php
</code></pre>

<p><img src="/uploads/wp/2011/06/console-shell-363x400.png" alt="" /></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Automatyczne ładowanie klas w dowolnym projekcie PHP z komponentem ClassLoader Symfony2]]></title>
            <link href="http://www.zalas.pl/automatyczne-ladowanie-klas-w-dowolnym-projekcie-php-z-komponentem-classloader-symfony2/"/>
            <updated>2011-06-30T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/automatyczne-ladowanie-klas-w-dowolnym-projekcie-php-z-komponentem-classloader-symfony2/</id>
            <content type="html"><![CDATA[<p><a href="https://github.com/symfony/ClassLoader">ClassLoader</a> to komponent <a href="http://symfony.com">Symfony2</a>, który odpowiada za automatyczne ładowanie klas zgodnie ze <a href="http://groups.google.com/group/php-standards/web/psr-0-final-proposal">standardem PSR-0</a>. Poza współpracą z kodem używającym przestrzeni nazw (ang. namespace), działa ze staromodnym już <a href="http://pear.php.net/manual/en/standards.naming.php">standardem PEAR</a> (używanym też w Zendzie). Komponent sprawdza się równie dobrze poza Symfony. <strong>Uwaga</strong>: Kod tworzony w tym wpisie jest dostępny na githubie: <a href="https://github.com/jakzal/SymfonyComponentsExamples">https://github.com/jakzal/SymfonyComponentsExamples</a></p>

<h2 id="instalacja">Instalacja</h2>

<p>Komponent możemy zainstalować z pomocą <a href="http://pear.symfony.com/">kanału PEAR Symfony</a> lub go po prostu pobrać z <a href="https://github.com/symfony/ClassLoader">github</a>a. Na potrzeby tego wpisu sklonujemy źródła do katalogu <em>vendor/</em> naszego projektu. <strong>Uwaga</strong>: Komponent ClassLoader używa przestrzeni nazw <em>Symfony\Component\ClassLoader</em>. Dlatego umieścimy go w podkatalogu <em>vendor/Symfony/Component/ClassLoader</em> (patrz <a href="http://groups.google.com/group/php-standards/web/psr-0-final-proposal">standard PSR-0</a>).</p>

<pre><code>git clone https://github.com/symfony/ClassLoader.git vendor/Symfony/Component/ClassLoader
</code></pre>

<h2 id="podstawowe-u%C5%BCycie">Podstawowe użycie</h2>

<p>Załóżmy, że mamy dwie biblioteki: Acme i Legacy_Acme. Pierwszą umieściliśmy w katalogu <em>src/Acme/Tools</em>. Jest w niej klasa <em>HelloWorld, która</em> używa przestrzeni nazw <em>Acme\Tools _i znajduje się w pliku _src/Acme/Tools/HelloWorld.php</em>:</p>

<pre><code>&lt;?php
// src/Acme/Tools/HelloWorld.php

namespace Acme\Tools;

class HelloWorld
{
    public function __construct()
    {
        echo __METHOD__."\n";
    }
}
</code></pre>

<p>Drugą bibliotekę umieściliśmy w katalogu <em>src/Legacy/Acme/Tools</em>. Używa konwencji PEAR, dlatego klasa <em>Legacy_Acme_Tools_HelloWorld</em> została zdefiniowana w pliku <em>src/Legacy/Acme/Tools/HelloWorld.php</em>:</p>

<pre><code>&lt;?php
// src/Legacy/Acme/Tools/HelloWorld.php

class Legacy_Acme_Tools_HelloWorld
{
    public function __construct()
    {
           echo __METHOD__."\n";
    }
}
</code></pre>

<p>Rejestrujemy przestrzeń nazw <em>Acme</em> oraz prefiks _Legacy__, aby nasze klasy były automatycznie ładowane:</p>

<pre><code>&lt;?php
// classloader.php

require_once __DIR__.'/vendor/Symfony/Component/ClassLoader/UniversalClassLoader.php';
$loader = new Symfony\Component\ClassLoader\UniversalClassLoader();
$loader-&gt;registerNamespaces(array('Acme' =&gt; __DIR__ . '/src'));
$loader-&gt;registerPrefixes(array('Legacy_' =&gt; __DIR__ . '/src'));
$loader-&gt;register();

$helloWorld = new Acme\Tools\HelloWorld();
$legacyHelloWorld = new Legacy_Acme_Tools_HelloWorld();
</code></pre>

<p>Oczywiście klasy zostaną załadowane tylko wtedy, kiedy będą potrzebne. Ręczne ładowanie <em>UniversalClassLoader.php</em> powinno być jedynym wywołaniem <em>require</em> w naszym kodzie. Resztę klas załaduje autoloader. <strong>Uwaga</strong>: Możemy zdefiniować ścieżki metodami <em>registerNamespaceFallbacks()</em> i <em>registerPrefixFallbacks()</em>. ClassLoader użyje ich z przestrzeniami nazw lub prefiksami nie podanymi jawnie przez <em>registerNamespaces()</em> lub <em>registerPrefixes()</em>.</p>

<h2 id="poprawiamy-wydajno%C5%9B%C4%87">Poprawiamy wydajność</h2>

<p>W prawdziwych projektach ilość klas jest raczej duża. ClassLoader może mieć negatywny wpływ na wydajność, ponieważ przed załadowaniem klasy sprawdza, czy jej plik istnieje. Powinniśmy używać <em>ApcUniversalClassLoader</em>, aby unikać niepotrzebnych operacji na dysku (ścieżki trzymane są wtedy w pamięci):</p>

<pre><code>&lt;?php
// classloadercached.php

require_once __DIR__.'/vendor/Symfony/Component/ClassLoader/UniversalClassLoader.php';
require_once __DIR__.'/vendor/Symfony/Component/ClassLoader/ApcUniversalClassLoader.php';

$loader = new Symfony\Component\ClassLoader\ApcUniversalClassLoader('ClassLoader');
$loader-&gt;registerNamespaces(array('Acme' =&gt; __DIR__ . '/src'));
$loader-&gt;registerPrefixes(array('Legacy_' =&gt; __DIR__ . '/src'));
$loader-&gt;register();

$helloWorld = new Acme\Tools\HelloWorld();
$legacyHelloWorld = new Legacy_Acme_Tools_HelloWorld();
</code></pre>

<p><strong>Uwaga</strong>: Przykłady uruchamiane są w konsoli, więc nie zyskamy na wydajności używając APC. Możemy nawet stracić, bo cache inicjalizowany będzie przy każdym uruchomieniu. Jest to ograniczenie APC.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Konfiguracja środowiska deweloperskiego PHP z Nginx w Ubuntu 11.04]]></title>
            <link href="http://www.zalas.pl/konfiguracja-srodowiska-deweloperskiego-php-z-nginx-w-ubuntu-1104/"/>
            <updated>2011-05-05T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/konfiguracja-srodowiska-deweloperskiego-php-z-nginx-w-ubuntu-1104/</id>
            <content type="html"><![CDATA[<p><img src="/uploads/wp/2011/05/nginx-php.png" alt="" />Opisywałem już <a href="/konfiguracja-srodowiska-deweloperskiego-php-z-nginx-w-ubuntu-1004">jak przygotować PHP do pracy z Nginx w Ubuntu 10.04</a>. W Ubuntu <strong>11.04</strong> (Natty Narwhal) procedura jest dużo prostsza za sprawą <strong>PHP 5.3</strong> i obecnego w nim <a href="http://pl.php.net/manual/en/install.fpm.php">php-fpm</a>. Ponieważ w międzyczasie udało mi się też ulepszyć swoją konfigurację <strong>Nginx</strong> dla PHP, postanowiłem opisać temat jeszcze raz.</p>

<h2 id="php">PHP</h2>

<p>Na początek instalujemy pakiety i moduły PHP (dobieramy wedle potrzeb):</p>

<pre><code>sudo apt-get install php5-fpm php5-cli php5-common php5-curl php5-gd \
  php5-mcrypt php5-mysql php5-pgsql php5-sqlite php5-tidy php5-xmlrpc \
  php5-xsl php5-intl php5-imagick php5-xdebug php-apc php-pear
</code></pre>

<p>Wszystkie pliki konfiguracyjne do PHP i php-fpm znajdziemy w katalogu <em>/etc/php5/fpm</em>. Jednak na początek domyślna konfiguracja powinna nam wystarczyć.</p>

<h2 id="nginx">Nginx</h2>

<p>Instalujemy Nginx ze standardowymi modułami:</p>

<pre><code>sudo apt-get install nginx
</code></pre>

<p>Zwykle pracuję z pseudodomenami <em>.dev</em> (kuba.dev, mojprojekt.dev itd). Wszystkie obsługiwane są przez jedną konfigurację <em>(/etc/nginx/sites-available/dev</em>):</p>

<pre><code>server {
    listen 80 default;
    server_name *.dev;

    root /var/www/$host/web;

    access_log /var/log/nginx/$host-access.log;
    error_log  /var/log/nginx/dev-error.log error;

    index index.php index.html index.htm;

    try_files $uri $uri/ @rewrite;

    location @rewrite {
        rewrite ^/(.*)$ /index.php/$1;
    }   

    location ~ \.php {
        # try_files $uri =404;

        fastcgi_index index.php;
        fastcgi_pass 127.0.0.1:9000;

        include fastcgi_params;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    location ~ /\.ht {
        deny all;
    }
}
</code></pre>

<p>Musimy ją uaktywnić:</p>

<pre><code>sudo ln -s /etc/nginx/sites-available/dev /etc/nginx/sites-enabled/dev
</code></pre>

<p><strong>Uwaga</strong>: Szczegóły dotyczące poszczególnych opcji i dyrektyw Nginx opisałem w artykule "<a href="/konfiguracja-nginx-dla-projektow-symfony">Konfiguracja Nginx dla projektów Symfony</a>" (konfiguracja jest dość uniwersalna).</p>

<h2 id="konfiguracja-systemu">Konfiguracja systemu</h2>

<p>Dodajemy siebie do grupy <em>www-data</em> i logujemy ponownie:</p>

<pre><code>sudo usermod -a -G www-data kuba
sudo su kuba
</code></pre>

<p>Robimy to, aby później nie nadużywać <em>sudo</em> za każdym razem, gdy będziemy pracować nad jedną z naszych aplikacji. Wystarczy, że zadbamy, aby pliki należały do grupy <em>www-data</em>. Pozwalamy, aby wszyscy w grupie mogli tworzyć domeny:</p>

<pre><code>sudo mkdir /var/www
sudo chown -R www-data:www-data /var/www
sudo chmod -R 775 /var/www
</code></pre>

<p>Definiujemy fikcyjne domeny <em>*.dev</em> w <em>/etc/hosts</em> (dużo wygodniej jest użyć dnsmasq, ale na początek plik hosts załatwi sprawę):</p>

<pre><code>127.0.1.1 loki info.dev kuba.dev mojprojekt.dev
</code></pre>

<h2 id="testy">Testy</h2>

<p>Tworzymy stronę testową:</p>

<pre><code>mkdir /var/www/info.dev/web -p
echo "&lt;?php echo phpinfo(); ?&gt;" &gt; /var/www/info.dev/web/index.php
chown -R :www-data /var/www/info.dev
chmod -R 775 /var/www/info.dev
</code></pre>

<p>Uruchamiamy php-fpm i Nginx:</p>

<pre><code>sudo service php5-fpm start
sudo service nginx start
</code></pre>

<p>Gdy teraz odwiedzimy <em>http://info.dev</em> w przeglądarce, powinniśmy zobaczyć informacje o naszej instalacji PHP. <img src="/uploads/wp/2011/05/phpinfo-400x367.png" alt="" /></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Konfiguracja Nginx dla projektów Symfony]]></title>
            <link href="http://www.zalas.pl/konfiguracja-nginx-dla-projektow-symfony/"/>
            <updated>2011-04-29T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/konfiguracja-nginx-dla-projektow-symfony/</id>
            <content type="html"><![CDATA[<p><img src="/uploads/wp/2011/04/nginx-symfony.png" alt="" />Z okazji wydania wersji 1.0.0 odświeżyłem nieco swoją wiedzę o Nginx. Od czasu, kiedy po raz pierwszy go konfigurowałem, wzbogacił się o kilka nowych dyrektyw i zmiennych. Dzięki temu mogłem uprościć swoją konfigurację dla projektów Symfony (zarówno symfony 1.x jak i Symfony2). <strong>Uwaga:</strong> Konfiguracje dostępne w Internecie podatne są na wykonanie pliku niePHPowego jako PHP. Więcej o problemie w "<a href="https://nealpoole.com/blog/2011/04/setting-up-php-fastcgi-and-nginx-dont-trust-the-tutorials-check-your-configuration/">Setting up PHP-FastCGI and nginx? Don’t trust the tutorials: check your configuration!</a>". O samej instalacji Nginx w Ubuntu przeczytacie w "<a href="/konfiguracja-srodowiska-deweloperskiego-php-z-nginx-w-ubuntu-1104">Konfiguracji środowiska deweloperskiego PHP z Nginx w Ubuntu 11.04</a>".</p>

<h2 id="konfiguracja">Konfiguracja</h2>

<p>Według konwencji konfigurację każdego hosta dodajemy do osobnego pliku w katalogu <em>/etc/nginx/sites-available/</em> i tworzymy do niej dowiązanie symboliczne w <em>/etc/nginx/sites-enabled/</em>. Poniższe reguły dla domen deweloperskich umieścimy w <em>/etc/nginx/sites-available/dev</em> i utworzymy do nich link <em>/etc/nginx/sites-enabled/dev</em>.</p>

<pre><code>server {
    listen 80 default;
    server_name *.dev;

    root /var/www/$host/current/web;

    access_log /var/log/nginx/$host-access.log;
    error_log  /var/log/nginx/dev-error.log error;

    index app.php index.html index.htm;

    try_files $uri $uri/ @rewrite;

    location @rewrite {
        rewrite ^/(.*)$ /app.php/$1;
    }   

    location ~ \.php {
        # try_files $uri =404;

        fastcgi_index app.php;
        fastcgi_pass 127.0.0.1:9000;

        include fastcgi_params;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    location ~ /\.ht {
        deny all;
    }
}
</code></pre>

<h2 id="wyja%C5%9Bnienie-konfiguracji">Wyjaśnienie konfiguracji</h2>

<pre><code>    listen 80 default;
</code></pre>

<p>Nginx domyślnie nasłuchuje na porcie 80. W tym fragmencie istotny jest drugi parameter - "default". Dzięki niemu aktualnie tworzona konfiguracja wirtualnego hosta będzie domyślną.</p>

<pre><code>    server_name *.dev;
</code></pre>

<p>Konfigurujemy dynamiczny wirtualny host, który akceptuje każdą domenę <em>.dev</em> (<em>kuba.dev</em>, <em>mojprojekt.dev</em> itd). Alternatywnie możemy podać listę domen  (np <em>server_name zalas.pl</em>). W takim przypadku każdy host zdefiniujemy w osobnej sekcji <em>server {}</em>.</p>

<pre><code>    root /var/www/$host/current/web;
</code></pre>

<p>Wskazujemy katalog główny domeny. Zostanie ustalony dynamicznie na podstawie zmiennej <em>$host</em> (dla domeny <em>kuba.dev</em> będzie to <em>/var/www/kuba.dev/current/web</em>)<em>.</em></p>

<pre><code>    access_log /var/log/nginx/$host-access.log;
    error_log  /var/log/nginx/dev-error.log error;
</code></pre>

<p>Definiujemy pliki logów. Każda domena otrzyma swój własny access log. Niestety nie możemy użyć zmiennej <em>$host</em> przy logowaniu błędów. Stąd wszystkie będą logowane do jednego pliku.</p>

<pre><code>    index app.php index.html index.htm;
</code></pre>

<p>Ustalamy pliki indeksu. Jeśli żądanie dotyczyć będzie katalogu, to nginx spróbuje wywołać pliki tutaj wypisane. W Symfony2 domyślny kontroler to zwykle <em>app.php</em>, a w symfony 1.x <em>index.php</em>.</p>

<pre><code>    try_files $uri $uri/ @rewrite;
</code></pre>

<p>Jest to bardzo elegancki sposób na czytelne URLe. Pozwala uniknąć <a href="http://wiki.nginx.org/IfIsEvil">niezalecanych ifów</a>. Serwer sprawdzi najpierw, czy istnieje plik o danym URI, następnie  poszuka katalogu, a na końcu skieruje żądanie do tzw <em>named location</em>.</p>

<pre><code>    location @rewrite {
        rewrite ^/(.*)$ /app.php/$1;
    }
</code></pre>

<p>Trafimy tutaj tylko, jeśli URI nie jest fizycznym plikiem lub katalogiem (w przeciwnym razie zadziała pierwszy lub drugi parametr dyrektywy <em>try_files</em>). Żądanie zostanie skierowane do domyślnego kontrolera (<em>app.php</em>).</p>

<pre><code>    location ~ \.php {
        fastcgi_index app.php;
        fastcgi_pass 127.0.0.1:9000;

        include fastcgi_params;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
</code></pre>

<p>Wszystkie żądania do PHP zostaną przekierowane do demona fastcgi (działającego lokalnie na porcie 9000). Oprócz dołączenia standardowych parametrów fastcgi z pliku fastcgi_params, zadbaliśmy o poprawną definicję PATH_INFO i SCRIPT_FILENAME. <em>fastcgi_split_path_info</em> podpowiada jak oddzielić plik kontrolera od ścieżki.</p>

<pre><code>    location ~ /\.ht {
        deny all;
    }
</code></pre>

<p>Ignorujemy apache'owe pliki .htaccess, które dla nginx są tylko zwykłymi, tekstowymi plikami (nie chcemy żeby były dostępne przez przeglądarkę).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Kompilacja Doctrine w symfony 1.4]]></title>
            <link href="http://www.zalas.pl/kompilacja-doctrine-w-symfony/"/>
            <updated>2011-04-27T00:00:00+00:00</updated>
            <id>http://www.zalas.pl/kompilacja-doctrine-w-symfony/</id>
            <content type="html"><![CDATA[<p><img src="/uploads/wp/2011/04/doctrine.png" alt="" /> Z reguły przy profilowaniu aplikacji symfony 1.x wychodzi, że budowanie obiektów przez Doctrine jest jedną z bardziej pracochłonnych operacji. Ostatnio miałem ciekawszy przypadek. Znaczącą część czasu wykonania skryptu zajmowało ładowanie klas ORMa (<em>require_once</em>!). W normalnych warunkach tego typu operacje są prawie niewidoczne. Z pomocą przyszedł mechanizm kompilacji, który łączy pliki z głównymi klasami Doctrine w jeden. Dzięki temu większość klas potrzebnych Doctrine podczas żądania załączanych jest tylko raz. W pluginie <a href="http://www.symfony-project.org/plugins/sfTaskExtraPlugin">sfTaskExtraPlugin</a> znajdziemy task <em>doctrine:compile</em>, który realizuje to zadanie. <strong>Notatka</strong>:  serwer, na którym zainstalowano wspomnianą aplikację miał więcej problemów (np źle skonfigurowane APC). Uwydatniły one problem wolnego ładowania klas. Nie mniej jednak kompilacja miała swój wkład w poprawę wydajności.</p>

<h2 id="instalacja-sftaskextraplugin">Instalacja sfTaskExtraPlugin</h2>

<pre><code>./symfony plugin:install sfTaskExtraPlugin
</code></pre>

<h2 id="kompilacja-doctrine">Kompilacja Doctrine</h2>

<p>Doctrine skompilujemy tylko ze wsparciem dla mysql, a wynik zapiszemy do pliku <em>lib/doctrine.compiled.php</em>:</p>

<pre><code>./symfony doctrine:compile --driver=mysql lib/doctrine.compiled.php
</code></pre>

<p>Tak jak zasugeruje nam komunikat po kompilacji, załączamy skompilowany plik w <em>ProjectConfiguration</em>:</p>

<pre><code>public function setup()
{
  // ...

  if ($this instanceof sfApplicationConfiguration &amp;&amp; !$this-&gt;isDebug())
  {
    require_once sfConfig::get('sf_lib_dir') . '/doctrine.compiled.php';
  }
}
</code></pre>

<p>Warunkiem poprawnego działania aplikacji po kompilacji jest używanie klasy <em>Doctrine_Core</em>, a nie <em>Doctrine</em>. Task działa z najnowszymi wersjami symfony 1.3 i 1.4.</p>
]]></content>
        </entry>
    </feed>